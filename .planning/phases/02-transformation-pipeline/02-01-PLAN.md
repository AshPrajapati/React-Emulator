---
phase: 02-transformation-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [package.json, src/utils/transform.js, src/App.jsx]
autonomous: true

must_haves:
  truths:
    - "User code with JSX syntax transforms to plain JavaScript"
    - "Transformation happens after 300ms debounce"
    - "React/hooks imports are auto-injected"
    - "Transform errors display without crashing app"
  artifacts:
    - path: "src/utils/transform.js"
      provides: "Babel transformation function"
      exports: ["transformCode"]
    - path: "src/App.jsx"
      provides: "Debounced transformation integration"
      contains: "useEffect.*debounce"
  key_links:
    - from: "src/App.jsx"
      to: "src/utils/transform.js"
      via: "import and call transformCode"
      pattern: "transformCode\\(code\\)"
    - from: "transform.js"
      to: "@babel/standalone"
      via: "Babel.transform API"
      pattern: "Babel\\.transform"
---

<objective>
Implement JSX-to-JavaScript transformation using Babel standalone with debounced execution and error handling.

Purpose: Enable user's React JSX code to be transformed into executable JavaScript for the preview pane.
Output: Transform service that converts JSX to JS with auto-injected React imports and graceful error handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-editor-shell-layout/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Babel and create transform service</name>
  <files>package.json, src/utils/transform.js</files>
  <action>
    1. Install @babel/standalone as a dependency (not devDependency, as it runs in the browser):
       - Run: npm install @babel/standalone

    2. Create src/utils/transform.js with:
       - Import Babel from '@babel/standalone'
       - Create transformCode function that:
         a. Auto-injects React/hook imports at the top if not present
         b. Uses Babel.transform() with react preset to convert JSX to JS
         c. Returns { success: true, code: transformedCode } on success
         d. Returns { success: false, error: errorMessage } on failure
       - Configure Babel with presets: ['react'] for JSX transformation
       - Handle import resolution: When user imports 'react', map it to window.React
       - For unavailable packages (e.g., axios), return clear error: "[package] is not available"

    Important: The transformed code should be module-compatible JavaScript that can run in an iframe.
  </action>
  <verify>
    - npm list @babel/standalone shows it's installed
    - src/utils/transform.js exists and exports transformCode function
    - Test transformation in browser console: transformCode('const el = <div>Hi</div>') returns valid JS
  </verify>
  <done>
    - @babel/standalone installed as dependency
    - transform.js created with working JSX transformation
    - Function returns success/error objects appropriately
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate transformation with debounce</name>
  <files>src/App.jsx</files>
  <action>
    1. Import transformCode from './utils/transform'
    2. Add new state for transformed code and transform errors:
       - const [transformedCode, setTransformedCode] = useState('')
       - const [transformError, setTransformError] = useState(null)

    3. Implement debounced transformation in useEffect:
       - Watch the 'code' state variable
       - Set up 300ms debounce timer
       - Call transformCode(code) after debounce
       - On success: setTransformedCode(result.code), setTransformError(null)
       - On error: setTransformError(result.error), keep previous transformedCode

    4. Pass transformedCode and transformError as props to preview (for now just log them):
       - console.log('Transformed:', transformedCode) on success
       - console.log('Transform error:', transformError) on error

    5. Update preview placeholder to show transform status:
       - If transformError: show error message in red
       - Otherwise: show "Preview Ready" (Phase 3 will execute the code)

    Clean up: Return cleanup function to clear timeout on unmount or code change.
  </action>
  <verify>
    - Type JSX code in editor and check browser console after 300ms
    - See "Transformed:" log with valid JavaScript (no JSX elements)
    - Type invalid syntax and see "Transform error:" in console
    - Rapid typing should only trigger one transform (debounce working)
  </verify>
  <done>
    - Transformation integrated with 300ms debounce
    - Transform errors caught and logged
    - Preview pane shows error state when transform fails
    - No app crashes on syntax errors
  </done>
</task>

</tasks>

<verification>
1. Open dev server (npm run dev)
2. Type JSX code like: const App = () => <div>Hello</div>
3. Check browser console for transformed JavaScript after 300ms
4. Type invalid syntax like: const App = <div (missing closing)
5. Verify error appears without crashing the app
6. Type rapidly and verify only one transform happens (debounce working)
</verification>

<success_criteria>
- JSX code transforms to executable JavaScript
- 300ms debounce prevents transform on every keystroke
- React imports are auto-injected (user doesn't need to import)
- Transform errors display gracefully without crashing
</success_criteria>

<output>
After completion, create `.planning/phases/02-transformation-pipeline/02-01-SUMMARY.md`
</output>